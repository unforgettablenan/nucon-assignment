########################
# Below contains the code used to initialise and train the CNN
# The trained model is saved as 'weights.05-0.83-0.76.h5' and has a val_acc 0.76
########################

import os
import keras
import numpy as np
from keras.applications import ResNet50, VGG16
from keras.callbacks import ModelCheckpoint, EarlyStopping
from keras.models import Sequential
from keras.layers import Conv2D, Dense, Flatten, GlobalAveragePooling2D, Dropout
from keras.preprocessing.image import load_img, img_to_array, ImageDataGenerator

########################
# Train model on top of VGG16
########################

#resnet50_weights = '/Users/tengtinghuan/CNN/resnet50_weights_tf_dim_ordering_tf_kernels_notop.h5'
vgg16_weights = '/Users/tengtinghuan/CNN/vgg16_weights_tf_dim_ordering_tf_kernels_notop.h5'

nTrain, nVal = 1060,462
trainBatch, valBatch = 20,33
imgSize = 224
numClass = 11
trainDir, testDir = '/Users/tengtinghuan/CNN/nucon/train','/Users/tengtinghuan/CNN/nucon/test'

vggModel = VGG16(weights = vgg16_weights, include_top=False, input_shape = (imgSize, imgSize,3))

for i in vggModel.layers[:-4]:
    i.trainable = False
#vggModel.summary()    

## VGG model is set up, removed top & last 4 layers set to trainable

newMod = Sequential()
newMod.add(vggModel)
newMod.add(Flatten())
newMod.add(Dense(512, activation = 'relu'))
#newMod.add(Dropout(0.2))
newMod.add(Dense(numClass, activation = 'softmax'))

## Added new Dense layer for classification task

gen = ImageDataGenerator(rescale= 1./255)
#genAug = ImageDataGenerator(rescale = 1./255, horizontal_flip = True, rotation_range = 10, zoom_range=0.2, width_shift_range = 0.2, height_shift_range = 0.2, fill_mode = 'nearest')
trainGen = gen.flow_from_directory(trainDir, target_size = (imgSize,imgSize), batch_size = trainBatch, class_mode = 'categorical')
valGen = gen.flow_from_directory(testDir, target_size = (imgSize,imgSize), batch_size = valBatch, class_mode = 'categorical')

## Callbacks
checkPoint = ModelCheckpoint('6cWeights.{epoch:02d}-{val_loss:.2f}-{val_acc:.2f}.h5', verbose=1, monitor='val_acc',save_best_only=False , mode='auto')
earlyStop = EarlyStopping(monitor='val_acc')

newMod.compile(optimizer='sgd', loss='categorical_crossentropy', metrics = ['accuracy'])

history = newMod.fit_generator(trainGen, steps_per_epoch = nTrain/trainBatch, epochs = 8, validation_data= valGen, validation_steps=nVal/valBatch, use_multiprocessing = True, workers = 4, callbacks = [checkPoint, earlyStop])



########################
# Below code was used to test the predictions generated by the model
# Pass the list of img paths through getImages(), then pass the output tensor into getClasses()
########################

def getImages(imgPaths, imgHeight=imgSize, imgWidth=imgSize):
    imgs = [load_img(path, target_size = (imgHeight, imgWidth)) for path in imgPaths]
    imgArray = np.array([img_to_array(i) for i in imgs])
    tensor = preprocess_input(imgArray)
    return tensor
    
def getClasses(inp):
    guesses = model.predict_classes(inp)
    pred = []
    for i in guesses:
        pred.append(classes[i])
    return pred
